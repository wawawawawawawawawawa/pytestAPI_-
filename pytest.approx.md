# *pytest.approx*

1. ##### 格式及其参数意义

	- `approx`(*expected*, *rel=None*, *abs=None*, *nan_ok=False*)：断言两个数字(或两组数字)在一定的容差范围内彼此相等

	- 参数

		expected: 期望值

		rel: 相对公差，在不指定时默认为`1e-6`

		abs: 绝对公差

		nan_ok: 默认情况下，NaN(非数字)不被视为等于任何值，但是您可以通过将`nan_ok`参数设置为True 使其等于其自身

	​

2. ##### 使用场景及优点

	由于浮点运算的复杂性，有时候我们认为相等的两个数结果并非如此：

	```python
	>>> 0.1 + 0.2 == 0.3
	False
	```

	在编写用例确认浮点数是不是期望的值时，通常会遇到上述的问题，解决方法之一是断言两个浮点数在某个适当的公差范围内是否相等：

	```
	>>> abs((0.1 + 0.2) - 0.3) < 1e-6
	True
	```

	但是这样的写法繁琐且难以理解，所以通常不提倡上述的表现方式。

	`approx`类执行语法时可以尽可能的使浮点数的比较更加直观：

	```
	>>> from pytest import approx
	>>> 0.1 + 0.2 == approx(0.3)
	True
	```

	相同的语法也适用于数字序列：

	```
	>>> (0.1 + 0.2, 0.2 + 0.4) == approx((0.3, 0.6))
	True
	```

	字典值：

	```
	>>> {'a': 0.1 + 0.2, 'b': 0.2 + 0.4} == approx({'a': 0.3, 'b': 0.6})
	True
	```

	`numpy` 数组：

	```
	>>> import numpy as np                                                          
	>>> np.array([0.1, 0.2]) + np.array([0.2, 0.4]) == approx(np.array([0.3, 0.6])) 
	True
	```

3. ##### 相对公差和绝对公差

	默认情况下`approx`认为相对公差在`1e-6`(即百万分之一)内的浮点数相等，可以通过将参数传递给`approx`

	构造函数来更改相对公差和绝对公差：

	```python
	>>> 1.0001 == approx(1)
	False
	>>> 1.0001 == approx(1, rel=1e-3)
	True
	>>> 1.0001 == approx(1, abs=1e-3)
	True
	```

	如果只指定`abs`,则比较时不考虑相对公差，换句话说，相对公差为`1e-6`的两个数，如果超过了指定的绝对公差，则依旧不相等，如果同时指定了相对公差(del)和绝对公差(abs)，则满足一个就是True

	```python
	>>> 1 + 1e-8 == approx(1)
	True
	>>> 1 + 1e-8 == approx(1, abs=1e-12)
	False
	>>> 1 + 1e-8 == approx(1, rel=1e-6, abs=1e-12)
	True
	```

4. ##### warning

	不能用于`>,<,>=,<=`,会报类型错误